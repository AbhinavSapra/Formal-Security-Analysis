(*
FSA-Assignment-P2
Abhinav Sapra
BMC202002
*)

(*
   A -> B: msg
   B -> A: f(msg)
   
   f is a remote procedure, private to B. So A should not use f in any of its 
   internal tests.
   
   A sends some large term which uses encryption, signatures etc. and has msg 
   embedded in it. B sends f(msg) embedded in a term using encryption, 
   signatures, and enough other information that enables A to verify that the 
   response is generated by someone running the B role.   
*)

free ch: channel.

type skey.
type pkey.
fun pk(skey):pkey.

fun penc(pkey,bitstring): bitstring.
reduc forall sk:skey, m:bitstring;
      pdec(sk,penc(pk(sk),m)) = m.

fun sign(skey,bitstring): bitstring.
reduc forall sk:skey, m:bitstring;
      verify(pk(sk),m,sign(sk,m)) = true.


free msg:bitstring [private].
free msgAtt:bitstring.

fun f(bitstring):bitstring [private].

event honest(pkey).

(* Secrecy of msg and f(msg): SHOULD BE TRUE *)
query attacker(msg).
query attacker(f(msg)).

(* Request Authentication: SHOULD BE TRUE *)
event SendA(bitstring).
event RecvB(pkey,bitstring).
query m:bitstring, pkx:pkey; 
      event(honest(pkx)) && event(RecvB(pkx,m)) ==> event(SendA(m)).

(* Response Authentication: SHOULD BE TRUE *)
event SendB(bitstring,bitstring).
event RecvA(pkey,bitstring,bitstring).
query req:bitstring,resp:bitstring, pkx:pkey;
      event(honest(pkx)) && event(RecvA(pkx,req,resp)) ==> event(SendB(req,resp)).

(* Reachability Queries: sanity checks SHOULD BE FALSE *)
query req:bitstring; event(SendA(req)).
query req:bitstring, pkx:pkey; event(RecvB(pkx,req)).
query req:bitstring, resp:bitstring; event(SendB(req,resp)).
query req:bitstring, resp:bitstring, pkx:pkey; event(RecvA(pkx,req,resp)).

(* A -> B: m *)
let A(skA:skey,pkB:pkey,req:bitstring) =
      event SendA(req);
      out(ch, penc(pkB,(req,pk(skA),sign(skA,(req,pkB)))));
      in(ch, x:bitstring);
      let (resp:bitstring,sig:bitstring) = pdec(skA,x) in
      if verify(pkB,(resp,pk(skA)),sig) then event RecvA(pkB,req,resp);
0.

(* B -> A: f(m) *)
let B(skB:skey) =
      in(ch, x:bitstring);
      let (req:bitstring,pkA:pkey,sig:bitstring) = pdec(skB,x) in
      if verify(pkA,(req,pk(skB)),sig) then
            event RecvB(pkA,req);
            let resp = f(req) in
            event SendB(req,resp);
            out(ch, penc(pkA,(resp,sign(skB,(resp,pkA)))));
0.

process

  new skA: skey;
  new skB: skey;
  new skI: skey;
  let pkA = pk(skA) in
  let pkB = pk(skB) in
  let pkI = pk(skI) in
  out(ch,skI);
  out(ch,(pkA,pkB));
  event honest(pkA);
  event honest(pkB);
  A(skA,pkB,msg) | A(skA,pkI,msgAtt) | B(skB) | B(skB)
